import { PDFDocument, PDFPage, rgb, StandardFonts, PDFFont } from "pdf-lib";
import { ForensicData, ForensicsService } from "../forensics";

export class ForensicPageGenerator {
  static async addForensicPage(
    pdfDoc: PDFDocument, 
    forensicData: ForensicData,
    originalFilename?: string
  ): Promise<PDFDocument> {
    let page = pdfDoc.addPage();
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    
    const { width, height } = page.getSize();
    const margin = 50;
    const lineHeight = 16;
    let y = height - margin;
    
    // Title
    page.drawText('ELECTRONIC SIGNATURE VERIFICATION', {
      x: margin,
      y: y,
      size: 16,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    // Underline
    y -= 8;
    page.drawLine({
      start: { x: margin, y: y },
      end: { x: width - margin, y: y },
      thickness: 2,
      color: rgb(0, 0, 0),
    });
    
    y -= 30;
    
    // Document info section
    const sections = [
      {
        title: 'DOCUMENT INFORMATION',
        content: [
          `Document: ${originalFilename || 'signed-document.pdf'}`,
          `Document Hash (SHA-256): ${forensicData.documentHash}`,
          `Signed: ${ForensicsService.formatTimestamp(forensicData.timestamp)}`,
          `Signed at: https://sign.silv.app`,
          `Session ID: ${forensicData.sessionId}`,
          `Consent Given: ${ForensicsService.formatTimestamp(forensicData.consentTimestamp)}`,
        ]
      },
      {
        title: 'SYSTEM INFORMATION',
        content: [
          `Browser: ${forensicData.browserFingerprint.browserName} ${forensicData.browserFingerprint.browserVersion}`,
          `Operating System: ${forensicData.browserFingerprint.operatingSystem} ${forensicData.browserFingerprint.osVersion}`,
          `Platform: ${forensicData.browserFingerprint.platform}`,
          `IP Address: ${forensicData.ipAddress || 'Not Available'}`,
          `Timezone: ${forensicData.browserFingerprint.timezone}`,
          `Language: ${forensicData.browserFingerprint.language}`,
        ]
      },
      {
        title: 'DEVICE & DISPLAY',
        content: [
          `Screen Resolution: ${forensicData.browserFingerprint.screenResolution}`,
          `Color Depth: ${forensicData.browserFingerprint.colorDepth}-bit`,
          `Available Screen: ${forensicData.browserFingerprint.availableScreenSize}`,
          `Window Size: ${forensicData.browserFingerprint.windowSize}`,
          `Hardware Cores: ${forensicData.browserFingerprint.hardwareConcurrency}`,
          ...(forensicData.browserFingerprint.deviceMemory ? [`Device Memory: ${forensicData.browserFingerprint.deviceMemory}GB`] : []),
          `Touch Points: ${forensicData.browserFingerprint.maxTouchPoints}`,
        ]
      },
      {
        title: 'FORENSIC FINGERPRINT',
        content: [
          `Unique Visitor ID: ${forensicData.visitorId}`,
          `Canvas Fingerprint: ${this.truncateText(forensicData.browserFingerprint.canvasFingerprint, 60)}`,
          `WebGL Vendor: ${forensicData.browserFingerprint.webglVendor}`,
          `WebGL Renderer: ${this.truncateText(forensicData.browserFingerprint.webglRenderer, 60)}`,
          `Connection Type: ${forensicData.browserFingerprint.connectionType}`,
          `Plugins Detected: ${forensicData.browserFingerprint.pluginsCount}`,
          `MIME Types: ${forensicData.browserFingerprint.mimeTypesCount}`,
        ]
      },
      {
        title: 'LEGAL COMPLIANCE',
        content: [
          '✓ ESIGN Act Compliant',
          '✓ UETA Compliant',
          '✓ User Consent Obtained',
          '✓ Forensic Audit Trail Complete',
          '✓ Document Integrity Verified',
        ]
      },
      {
        title: 'PRIVACY PROTECTION',
        content: [
          '✓ All processing performed locally in browser',
          '✓ No data transmitted to or stored on servers',
          '✓ Forensic information embedded in PDF only',
          '✓ User maintains complete control of document',
        ]
      }
    ];
    
    for (const section of sections) {
      y = this.addSection(page, section.title, section.content, margin, y, lineHeight, helveticaBold, helvetica);
      y -= 10; // Extra space between sections
    }
    
    // Legal notice
    y -= 10;
    const legalNotice = [
      'This document was electronically signed using privacy-first technology.',
      'All forensic data was collected with explicit user consent for legal',
      'compliance purposes only.',
      '',
      `Document Hash (SHA-256): ${forensicData.documentHash}`,
      'Generated by: PDF Signer - Privacy-First Electronic Signatures',
      '',
      'Legal Notice: This electronic signature complies with the Electronic',
      'Signatures in Global and National Commerce (ESIGN) Act and the Uniform',
      'Electronic Transactions Act (UETA). The embedded forensic information',
      'provides technical evidence of signing authenticity and intent for',
      'legal proceedings.',
    ];
    
    for (const line of legalNotice) {
      if (y < margin + 50) {
        // Not enough space, create new page
        const newPage = pdfDoc.addPage();
        y = newPage.getSize().height - margin;
        page = newPage as PDFPage;
      }
      
      page.drawText(line, {
        x: margin,
        y: y,
        size: 10,
        font: helvetica,
        color: rgb(0.3, 0.3, 0.3),
      });
      y -= 14;
    }
    
    return pdfDoc;
  }
  
  private static addSection(
    page: PDFPage,
    title: string,
    content: string[],
    margin: number,
    startY: number,
    lineHeight: number,
    boldFont: PDFFont,
    regularFont: PDFFont
  ): number {
    let y = startY;
    
    // Section title
    page.drawText(title, {
      x: margin,
      y: y,
      size: 12,
      font: boldFont,
      color: rgb(0, 0, 0),
    });
    
    // Underline
    y -= 6;
    page.drawLine({
      start: { x: margin, y: y },
      end: { x: margin + 200, y: y },
      thickness: 1,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    y -= lineHeight;
    
    // Section content
    for (const line of content) {
      page.drawText(line, {
        x: margin,
        y: y,
        size: 10,
        font: regularFont,
        color: rgb(0, 0, 0),
      });
      y -= lineHeight;
    }
    
    return y;
  }
  
  private static truncateText(text: string, maxLength: number): string {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }
}

// Enhanced export function that includes forensic page
export async function stampPdfWithForensics(
  originalBytes: ArrayBuffer,
  annotations: unknown[],
  forensicData: ForensicData,
  originalFilename?: string
): Promise<Uint8Array> {
  // Import the existing stamp function to reuse its logic
  const { stampPdf } = await import('./export');
  
  // First, stamp the PDF with annotations
  const stampedPdfBytes = await stampPdf(originalBytes, annotations);
  
  // Then load the stamped PDF and add the forensic page
  const pdfDoc = await PDFDocument.load(stampedPdfBytes);
  const pdfWithForensics = await ForensicPageGenerator.addForensicPage(
    pdfDoc, 
    forensicData, 
    originalFilename
  );
  
  // Add PDF metadata
  pdfWithForensics.setTitle(`Electronically Signed: ${originalFilename || 'Document'}`);
  pdfWithForensics.setAuthor('PDF Signer - Privacy-First Electronic Signatures');
  pdfWithForensics.setSubject(`Electronically Signed Document with Forensic Documentation | Hash: ${forensicData.documentHash} | Fingerprint: ${forensicData.visitorId}`);
  pdfWithForensics.setKeywords([
    'electronic signature',
    'ESIGN Act compliant',
    'UETA compliant',
    'forensic documentation',
    'digitally signed',
    `document-hash-${forensicData.documentHash}`,
    `fingerprint-${forensicData.visitorId}`,
    `session-${forensicData.sessionId}`
  ]);
  pdfWithForensics.setProducer(`PDF Signer v1.0 | Session: ${forensicData.sessionId}`);
  pdfWithForensics.setCreator(`PDF Signer - Privacy-First Electronic Signatures | Fingerprint: ${forensicData.visitorId}`);
  pdfWithForensics.setCreationDate(new Date(forensicData.timestamp));
  pdfWithForensics.setModificationDate(new Date(forensicData.timestamp));
  
  return pdfWithForensics.save({ useObjectStreams: false });
}